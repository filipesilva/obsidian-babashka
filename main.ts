import { App, Editor, EditorPosition, MarkdownView, Modal, Notice, Plugin, PluginSettingTab, Setting, FileSystemAdapter } from 'obsidian';
import { exec } from 'child_process';
import { existsSync, writeFileSync } from 'fs';
import { resolve } from 'path';

const DEFAULT_OUTPUT_LIMIT = 1000;

function getVaultRoot(app: App) {
	return (app.vault.adapter as FileSystemAdapter).getBasePath();
}

interface Codeblock {
	lang: string,
	code: string,
	insideInsertPos: EditorPosition,
	outsideInsertPos: EditorPosition,
}

function getCodeblockForCursor(editor: Editor): Codeblock | null {
	const src = editor.getValue();
	const cursor = editor.getCursor();
	const cljRe = /^```(clojure|clojurescript)$\s([\s\S]*?)^```$/gmd;
	const cljCodeblocks = Array.from(src.matchAll(cljRe));
	const cursorOffset = editor.posToOffset(cursor);
	const insideMatch = (offset: any) => (match: any) => match.indices[0][0] <= offset && offset <= match.indices[0][1];
	const match: any = cljCodeblocks.find(insideMatch(cursorOffset));

	if (match) {
		return {
			lang: match[1],
			code: match[2],
			insideInsertPos: editor.offsetToPos(match.indices[2][1]),
			outsideInsertPos: editor.offsetToPos(match.indices[0][1]),
		}
	} else {
		return null;
	}
}

function validateSettingsForCodeblock(codeblock: Codeblock, settings: PluginSettings) {
	const { lang } = codeblock;
	const { bbPath, nbbPath, nodePath } = settings;

	if (lang == 'clojure' && !bbPath) {
		new Notice('Please set Babashka path in settings');
		return false;
	}

	if (lang == 'clojurescript' && (!nbbPath || !nodePath)) {
		new Notice('Please set both Node Babashka and Node paths in settings');
		return false;
	}

	return true;
}

function capCharsAt(str: string, maxChars: number) {
	if (str.length > maxChars) {
		return str.substring(0, maxChars) + `\n... and ${str.length - maxChars} more chars}`;
	} else {
		return str;
	}
}

function resolvePluginFolder(vaultPath: string, settings: PluginSettings) {
	return resolve(vaultPath, settings.bbDir);
}

function writeVaultBindingsNs(app: App, view: MarkdownView, settings: PluginSettings) {
	const vaultPath = getVaultRoot(this.app);
	const pluginFolder = resolvePluginFolder(vaultPath, settings);
	const bindingsNsPath = `${pluginFolder}/gen/vault_bindings.cljc`;

	const src = `(ns vault-bindings)
;; This file is auto-generated by the Babashka plugin when you execute a codeblock.
;; Don't edit it directly, it will be overwritten.
(def *vault-name* "${app.vault.getName()}")
(def *vault-path* "${vaultPath}")
(def *vault-babashka-path* "${pluginFolder}")
(def *last-folder-path* "${vaultPath}/${view.file.parent.path}")
(def *last-file-name* "${view.file.name}")
(def *last-file-path* "${vaultPath}/${view.file.path}")
`;

	writeFileSync(bindingsNsPath, src);
}

function writeDefaultBbEdn(app: App, settings: PluginSettings) {
	const vaultPath = getVaultRoot(this.app);
	const pluginFolder = resolvePluginFolder(vaultPath, settings);
	const bbEdnPath = `${pluginFolder}/bb.edn`;
	const nbbEdnPath = `${pluginFolder}/nbb.edn`;
	const src = `{:paths ["gen"]}`;

	if (!existsSync(bbEdnPath)) {
		writeFileSync(bbEdnPath, src);
	}

	if (!existsSync(nbbEdnPath)) {
		writeFileSync(nbbEdnPath, src);
	}
}

function executeCodeblock(
	codeblock: Codeblock, insertAt: "inside" | "outside",
	vaultPath: string, editor: Editor, settings: PluginSettings) {
	const { lang, code, insideInsertPos, outsideInsertPos } = codeblock;
	const { bbPath, nbbPath, nodePath, bbDir, limitOutput } = settings;

	if (validateSettingsForCodeblock(codeblock, settings)) {
		const bin = lang == 'clojure' ? bbPath : `${nodePath} ${nbbPath}`;
		const ext = lang == 'clojure' ? 'clj' : 'cljs';
		const pluginCwd = `${vaultPath}/${bbDir}`;

		const codeShellStr = code.replaceAll("\"", "\\\"");
		const cmd = `${bin} -e "${codeShellStr}"`;

		console.debug(`babashka executing: \`${cmd}\` on ${pluginCwd}`);
		// TODO: save process for kill?
		const p = exec(
			cmd,
			{ cwd: `${pluginCwd}` },
			(err, stdout, stderr) => {
				if (err) {
					const errorMsg = 'Error during execution:\n' + err;
					console.error(errorMsg)
					new Notice(errorMsg, 5000);
					return;
				}

				if (stderr) {
					const errorMsg = 'stderr during execution:\n' + stderr;
					console.error(errorMsg)
					new Notice(errorMsg, 5000);
					return;
				}

				if (stdout) {
					const cappedOutput = limitOutput ? capCharsAt(stdout, DEFAULT_OUTPUT_LIMIT) : stdout;

					if (insertAt == "inside") {
						const outputAsComments = cappedOutput.trim().replaceAll(/^/gm, ';; ');
						editor.replaceRange(`\n${outputAsComments}\n`, insideInsertPos, insideInsertPos);
					} else if (insertAt == "outside") {
						editor.replaceRange(`\n\n${cappedOutput}`, outsideInsertPos, outsideInsertPos);
					}
				}
				console.debug(`babashka stdout:\n${stdout}`);
				console.debug(`babashka stderr:\n${stderr}`);
			});
	}
}

interface PluginSettings {
	bbDir: string,
	bbPath: string,
	nbbPath: string,
	nodePath: string,
	limitOutput: boolean,
}

const DEFAULT_SETTINGS: PluginSettings = {
	bbDir: '.babashka',
	bbPath: '',
	nbbPath: '',
	nodePath: '',
	limitOutput: true,
}

export default class BabashkaPlugin extends Plugin {
	settings: PluginSettings;

	async onload() {
		await this.loadSettings();

		this.addSettingTab(new SettingTab(this.app, this));

		this.addCommand({
			id: 'obsidian-babashka-execute-codeblock',
			name: 'Execute codeblock',
			editorCallback: async (editor: Editor, view: MarkdownView) => {
				const codeblock = getCodeblockForCursor(editor);
				if (codeblock) {
					writeVaultBindingsNs(this.app, view, this.settings);
					writeDefaultBbEdn(this.app, this.settings);
					const vaultPath = getVaultRoot(this.app);
					executeCodeblock(codeblock, "inside", vaultPath, editor, this.settings);
				} else {
					new Notice('No clojure(script) codeblock found');
				}
			}
		});

		this.addCommand({
			id: 'obsidian-babashka-execute-codeblock-print-outside',
			name: 'Execute codeblock and print outside',
			editorCallback: async (editor: Editor, view: MarkdownView) => {
				const codeblock = getCodeblockForCursor(editor);
				if (codeblock) {
					writeVaultBindingsNs(this.app, view, this.settings);
					writeDefaultBbEdn(this.app, this.settings);
					const vaultPath = getVaultRoot(this.app);
					executeCodeblock(codeblock, "outside", vaultPath, editor, this.settings);
				} else {
					new Notice('No clojure(script) codeblock found');
				}
			}
		});
	}

	onunload() {

	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class SettingTab extends PluginSettingTab {
	plugin: BabashkaPlugin;

	constructor(app: App, plugin: BabashkaPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	addTextSetting(name: string, desc: string, placeholder: string, k: keyof PluginSettings) {
		const { containerEl } = this;
		new Setting(containerEl)
			.setName(name)
			.setDesc(desc)
			.addText(text => text
				.setPlaceholder(placeholder)
				.setValue(this.plugin.settings[k] as string)
				.onChange(async (value) => {
					(this.plugin.settings as any)[k] = value;
					await this.plugin.saveSettings();
				}));
	}

	addToggleSetting(name: string, desc: string, k: keyof PluginSettings) {
		const { containerEl } = this;
		new Setting(containerEl)
			.setName(name)
			.setDesc(desc)
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings[k] as boolean)
				.onChange(async (value) => {
					(this.plugin.settings as any)[k] = value;
					await this.plugin.saveSettings();
				}));
	}

	display(): void {
		const { containerEl } = this;

		containerEl.empty();

		containerEl.createEl('h2', { text: 'General' });
		this.addToggleSetting('Limit output', `Output will be truncated after ${DEFAULT_OUTPUT_LIMIT} characters.`, 'limitOutput');

		containerEl.createEl('h2', { text: 'Paths' });
		this.addTextSetting('Vault Babashka dir', 'Path to babashka dir from vault root. Can be absolute. Babashka will be run from this dir. You can put bb.edn, nbb.edn, and package.json files there to use dependencies.', '', 'bbDir');
		this.addTextSetting('Babashka path', 'Absolute path to babashka.', 'run `which bb` to see it', 'bbPath');
		this.addTextSetting('Node Babashka path', 'Absolute path to nbb.', 'run `which nbb` to see it', 'nbbPath');
		this.addTextSetting('Node path', 'Absolute path to node.', 'run `which nbb` to see it', 'nodePath');
	}
}
